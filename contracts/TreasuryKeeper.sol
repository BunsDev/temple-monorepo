pragma solidity ^0.8.4; // SPDX-License-Identifier: GPL-3.0-or-later

import "./TreasuryProxy.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/*
* The interface for Chainlink Keepers - see docs: https://docs.chain.link/docs/chainlink-keepers/introduction/
*/
interface KeeperCompatibleInterface {

    function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);

    function performUpkeep(bytes calldata performData) external;
}


contract TreasuryKeeper is KeeperCompatibleInterface {

    TempleTreasury private TREASURY;

    TreasuryProxy  private TREASURYPROXY;

    // Underlying STABLEC contract for Treaury
    IERC20 private STABLEC;

    constructor (address _treasury, address _treasuryProxy, address _stablec) public {
        TREASURY   = TempleTreasury(_treasury);
        TREASURYPROXY  = TreasuryProxy(_treasuryProxy);
        STABLEC  =  IERC20(STABLEC);
    }


    /**
      Chainlink Keeper Function that checks if conditions have been met to perform the next action
     */
    function checkUpkeep(bytes calldata checkData) external view override returns (bool upkeepNeeded, bytes memory performData) {

        (uint256 _stablec, ) = TREASURY.intrinsicValueRatio();

        bool harvestEnabled = TREASURYPROXY.harvestEnabled(); 

        uint256 currentTreasury = STABLEC.balanceOf(address(TREASURY));
        
        // Harvest for two percent increase in IV
        upkeepNeeded = harvestEnabled && _stablec * 102 /100 > currentTreasury;

        // We don't use the checkData
        // checkData was defined when the Upkeep was registered
        performData = checkData;
    }

    function performUpkeep(bytes calldata performData) external override {

        // Call temple treasury to do harvest
        TREASURYPROXY.harvest();

        // We don't use the performData in this example
        // performData is generated by the Keeper's call to your `checkUpkeep` function
        performData;
    }
}
