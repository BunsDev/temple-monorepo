require('dotenv').config();
import '@nomiclabs/hardhat-ethers';
import { task } from "hardhat/config";
import { BigNumber, ContractTransaction, Contract, ethers, Signer } from 'ethers';
import { readFileSync, writeFileSync } from 'fs';
import { ExitQueue__factory, TempleCashback__factory, TempleERC20Token__factory } from '../typechain';
import { HardhatRuntimeEnvironment } from 'hardhat/types';


const CONTRACT_ADDRESS: {[key: string]: {
  TEMPLE_ADDRESS: string,
}} = {
  rinkeby: {
    TEMPLE_ADDRESS: '0x3278b75A8C63b6B6A27F05551d6ECc16D0827269',
  },
  mainnet: {
    TEMPLE_ADDRESS: '0x470EBf5f030Ed85Fc1ed4C2d36B9DD02e77CF1b7',
  },
  localhost: {
    TEMPLE_ADDRESS: '0x5fbdb2315678afecb367f032d93f642f64180aa3',
  }
}

async function mine(tx: Promise<ContractTransaction>) {
  await (await tx).wait()
}

async function deployTempleLocal(owner: Signer) {
  const TEMPLE = await new TempleERC20Token__factory(owner).deploy();
  return TEMPLE;
}

async function createSignature(
  hre: HardhatRuntimeEnvironment,
  privateKey: ethers.utils.SigningKey,
  TEMPLE_CASHBACK: Contract,
  tokenAddress: string,
  recipient: string,
  tokenQuantity: BigNumber,
  nonce: number
) {
  const hash = await TEMPLE_CASHBACK.generateHash(
      tokenAddress,
      recipient,
      tokenQuantity,
      nonce
  )
  const signature = hre.ethers.utils.joinSignature(privateKey.signDigest(hash))
  return { signature, hash }
}


// sets temple owed by users. from csv file generated by ethpanda
// temple values should be 18 decimals
task("set-owed-temple", "Sets temple owed by users")
  .addParam("path", "path of csv file containing users owing")
  .addParam("exitqueue", "exit queue address")
  .setAction( async (args, hre) => {
    const [owner] = await hre.ethers.getSigners();
    const fileContent = readFileSync(args.path, 'utf8');
    const lines = fileContent.split("\n");
    const addresses = [];
    const amountsOwed = [];
    for (let i=0; i<lines.length; i++) {
      if (i == 0) continue; // skip header
      const [userAddress, _b, _c, _d, _e, templeOwed] = lines[i].split(",");
      if (userAddress) {
        addresses.push(userAddress);
        amountsOwed.push(BigNumber.from(templeOwed));
      }
    }
    const EXIT_QUEUE = new ExitQueue__factory(owner).attach(args.exitqueue);
    await mine(EXIT_QUEUE.setOwedTemple(addresses, amountsOwed));
  });

// generate signatures for users' claims
// temple values should be 18 decimals
// nonce used to avoid overlap/double usage
task("generate-signatures", "Generate signatures for claimable temple and owed temple")
  .addParam("path", "path of csv file containing (address, templeAmount)")
  .addParam("templecashback", "TempleCashback contract address")
  .addParam("nonce", "nonce to use for this batch of signatures")
  .addParam("outputdir", "output directory for generated json files")
  .setAction( async (args, hre) => {
    const [owner] = await hre.ethers.getSigners();
    const tokenAddress = CONTRACT_ADDRESS[hre.network.name].TEMPLE_ADDRESS;
    const nonce = args.nonce;
    const fileContent = readFileSync(args.path, 'utf8');
    const lines = fileContent.split("\n");
    let sigs: {[key: string]: { 
      hash: string, 
      signature: string, 
      tokenAddress: string, 
      tokenQuantity: string, 
      nonce: string }} = {} // address: { hash, signature, tokenAddress, tokenQuantity, nonce }
    const TEMPLE_CASHBACK = new TempleCashback__factory(owner).attach(args.templecashback);
    
    const privateKeyFilePath: string = process.env.PRIVATE_KEY_FILE!;
    const privateKeyFilePassword: string = process.env.PRIVATE_KEY_PASSWORD!;
    const privateKey = hre.ethers.Wallet.fromEncryptedJsonSync(
      readFileSync(privateKeyFilePath, 'utf8'),
      privateKeyFilePassword
    ).privateKey
    const signingKey = new hre.ethers.utils.SigningKey(privateKey);

    // generate signatures
    for (let i=0; i<lines.length; i++) {
      if (i==0) continue; // skip header
      const [userAddress, tokenQuantity] = lines[i].split(",");
      console.log(tokenQuantity);
      if (userAddress) {
        const { signature, hash } = 
          await createSignature(
            hre,
            signingKey,
            TEMPLE_CASHBACK,
            tokenAddress, 
            userAddress, 
            BigNumber.from(tokenQuantity), 
            Number(nonce)
          );
        sigs[userAddress] = { hash, signature, tokenAddress, tokenQuantity, nonce };
      }
    }
    // generate output file
    const outputFilePath = `${args.outputdir}/file-${nonce}.json`;
    writeFileSync(outputFilePath, JSON.stringify(sigs));
  });